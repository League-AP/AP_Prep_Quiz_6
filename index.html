<html>
<head>
            <title>League AP Prep - Quiz 6</title>

        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://league-central.github.io/curriculum/style/style.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
        <link rel="stylesheet" href="https://league-ap.github.io/style/style.css">
        <script src="https://league-central.github.io/curriculum/script/headerAndFooter.js"></script>
</head>
<div id="header">
	<center> <h1>
		Arrays and Array Lists Quiz
	</h1>    <br>
    <hr>
    <br></center>
</div>
<div id="quiz"></div>
<div id="nav">
    <div id="footer"></div>
</div>

<script>

var totalQuestions;

var qDiv;
var navDiv;

var currentQuestion;
var questions = [];
var qIndex = 0;

var quizComplete = false;
var score = 0;

function Question(){
	this.type;
	this.number;
	this.question;
	this.choices = [];
	this.correctAnswers = [];
	this.userAnswers = [];
	this.isCorrect = false;
}

window.onload = function(){
	qDiv = document.getElementById('quiz');
	navDiv = document.getElementById('nav');
	buildQuiz();

	navDiv.innerHTML += "NAVIGATION:<br>";
	for(var i = 0; i < totalQuestions; i++){
		navDiv.innerHTML += "<button onclick='navigateTo("+i+")'>"+(i + 1)+"</button>";
	}
	navDiv.innerHTML += "<br><br>";
	navDiv.innerHTML += "<button onclick='submitQuiz()'>Submit Quiz</button><br>";

    addFooter();
}

function buildQuiz(){
// These constants map answer indexes to letters shown on UI
const A = 0;
const B = 1;
const C = 2;
const D = 3;
const E = 4;

//Q12 from Diagnostic Test
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="Consider a Clown class that has a default constructor. Suppose a list <code>ArrayList&lt;Clown&gt; list</code> is initialized. Which of the following will <u>not</u> cause an <code>IndexOutOfBoundsException</code> to be thrown?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;<code>for (int i = 0; i <= list.size(); i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.set(i, new Clown());</code>";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;<code>list.add(list.size(),newClown());</code>";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;<code>Clown c = list.get(list.size());</code>";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;<code>Clown c = list.remove(list.size());</code>";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;<code>list.add(-1, new Clown());</code>";

    questions[qIndex].correctAnswers=B;

//Q13 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="<code>public class Tester<br>{<br>&nbsp;&nbsp;&nbsp;private int[] testArray = {3, 4, 5};<br><br>&nbsp;&nbsp;&nbsp;/** @param n an int to be incremented by 1 */<br>&nbsp;&nbsp;&nbsp;public void increment (int n)<br>&nbsp;&nbsp;&nbsp;{ n++; }<br><br>&nbsp;&nbsp;&nbsp;public void firstTestMethod()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; testArray.length; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment(testArray[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(testArray[i] + &quot; &quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public void secondTestMethod()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int element : testArray)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment(element);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(element + &quot; &quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br></code>What output will be produced by invoking <code>firstTestMethod</code> for a <code>Tester</code> object?<br>";


questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;3 4 5";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;4 5 6";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;5 6 7";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;0 0 0";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;No output will be produced. An ArrayIndexOutOfBoundsException will be thrown";

    questions[qIndex].correctAnswers=A;

//Q14 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="<code>public class Tester<br>{<br>&nbsp;&nbsp;&nbsp;private int[] testArray = {3, 4, 5};<br><br>&nbsp;&nbsp;&nbsp;/** @param n an int to be incremented by 1 */<br>&nbsp;&nbsp;&nbsp;public void increment (int n)<br>&nbsp;&nbsp;&nbsp;{ n++; }<br><br>&nbsp;&nbsp;&nbsp;public void firstTestMethod()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; testArray.length; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment(testArray[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(testArray[i] + &quot; &quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;public void secondTestMethod()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int element : testArray)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;increment(element);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(element + &quot; &quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br></code>What output will be produced by invoking <code>secondTestMethod</code> for a <code>Tester</code> object, assuming that <code>testArray</code> contains 3,4,5?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;3 4 5";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;4 5 6";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;5 6 7";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;0 0 0";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;No output will be produced. An ArrayIndexOutOfBoundsException will be thrown";

questions[qIndex].correctAnswers=A;

    
//Q18 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="Refer to the <code>doSomething</code> method:<br><br><code>// postcondition<br>public static void doSomething(List&lt;SomeType&gt; list, int i, int j)<br>{<br>&nbsp;&nbsp;&nbsp;SomeType temp = list.get(i);<br>&nbsp;&nbsp;&nbsp;list.set(i, list.get(j));<br>&nbsp;&nbsp;&nbsp;list.set(j, temp);<br>}</code><br><br>Which best describes the postcondition for doSomething?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;Removes from list the objects indexed at i and j";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;Replaces in list the object indexed at i with the object indexed at j";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;Replaces in list the object indexed at j with the object indexed at i";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;Replaces in list the objects indexed at i and j with temp";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;Interchanges in list the objects indexed at i and j";

questions[qIndex].correctAnswers=E;


//Q26 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="Refer to the following class, containing the <code>mystery</code> method.<br><br><code>public class SomeClass<br>{<br>&nbsp;&nbsp;&nbsp;private int[] arr;<br><br>&nbsp;&nbsp;&nbsp;/** Constructor. Initializes arr to contain nonnegative<br>&nbsp;&nbsp;&nbsp;* integers k such that 0 &lt;= k &lt;= 9.<br>&nbsp;&nbsp;&nbsp;*/<br>&nbsp;&nbsp;&nbsp;public SomeClass()<br>&nbsp;&nbsp;&nbsp;{ /* implementation not shown */ }<br><br>&nbsp;&nbsp;&nbsp;public int mystery()<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int value = arr[0];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 1; i &lt; arr.length; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = value * 10 + arr[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;<br>&nbsp;&nbsp;&nbsp;}<br>}<br></code><br>Which best describes what the mystery method does?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;It sums the elements of arr";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;It sums the products 10*arr[0]+10*arr[1]+···+10*arr[arr.length-1]";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;It builds an integer of the form d1 d2 d3 ...dn, where d1 =arr[0], d2 = arr[1], . . . , dn = arr[arr.length-1]";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;It builds an integer of the form d1 d2 d3 ...dn, where d1 = arr[arr.length-1], d2 = arr[arr.length-2], . . . , dn = arr[0].";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;It converts the elements of arr to base-10.";

questions[qIndex].correctAnswers=C;



//Q31 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="A matrix(two-dimensional array)is declared as<br><br><code>int[][] mat = new int[2][3];</code><br><br>Consider the following method:<br><br><code>public static void changeMatrix(int[][] mat)<br>{<br>&nbsp;&nbsp;&nbsp;for (int r = 0; r &lt; mat.length; r++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int c = 0; c &lt; mat[r].length; c++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (r == c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mat[r][c] = Math.abs(mat[r][c]);<br>}<br></code><br><br> If <code>mat</code> is initialized to be<br><br>-1, -2, -6<br>-2, -4,  5<br><br>which matrix will be the result of a call to <code>changeMatrix(mat)</code>?";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;1, -2, -6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2, 4, 5";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;-1, 2, -6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2, -4, 5";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;-1, -2, -6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2, -4, -5";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;1, 2, -6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2, 4, 5";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;1, 2, 6<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2, 4, 5";

questions[qIndex].correctAnswers=A;

    
    
 //Q33 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="A programmer plans to write a program that simulates a small bingo game (no more than six players). Each player will have a bingo card with 20 numbers from 0 to 90 (no duplicates). Someone will call out numbers one at a time, and each player will cross out a number on his card as it is called. The first player with all the numbers crossed out is the winner. In the simulation, as the game is in progress, each player’s card is displayed on the screen.<br><br>The programmer envisions a short driver class whose main method has just two statements:<br><br><code>BingoGame b = new BingoGame();<br> b.playBingo();</code><br><br>The BingoGame class will have several objects: a Display, a Caller, and a PlayerGroup. The PlayerGroup will have a list of Players, and each Player will have a BingoCard.<br><br>Which is a reasonable data structure for a <code>BingoCard</code> object? Recall that there are 20 integers from 0 to 90 on a <code>BingoCard</code>, with no duplicates. There should also be mechanisms for crossing off numbers that are called, and for detecting a winning card (i.e., one where all the numbers have been crossed off).<br><br>&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;<code>&nbsp;&nbsp;&nbsp;int numCrossedOff;&nbsp;&nbsp;&nbsp;//player wins when numCrossedOff reaches 20.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int[] bingoCard;&nbsp;&nbsp;&nbsp;//will contain 20 integers and bingoCard[k] is crossed off by setting it to -1.<br></code><br><br>&nbsp;&nbsp;&nbsp;II&nbsp;&nbsp;&nbsp;<code>&nbsp;&nbsp;&nbsp;int numCrossedOff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//player wins when numCrossedOff reaches 20<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean[] bingoCard;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//will contain 91 boolean values, of which <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//20 are true. All the other values are false.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Thus, if bingoCard[k] is true, then k is <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//on the card, 0 <= k <= 90. A number k is <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//crossed off by changing the value of <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//bingoCard[k] to false.<br></code><br>&nbsp;&nbsp;&nbsp;III&nbsp;&nbsp;&nbsp;<code>&nbsp;&nbsp;&nbsp;ArrayList<Integer> bingoCard; //will contain 20 integers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//A number is crossed off by removing it from the ArrayList.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Player wins when bingoCard.size() == 0.</code><br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;I only";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;II only";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;III only";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;I and II only";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;I, II, and III";

questions[qIndex].correctAnswers=E;

    
    
 //Q35 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="Consider method <code>findSomething</code> below:<br><br><code>/**Precondition: a.length is equal to b.length */<br>public static boolean findSomething(int[] a, int[] b)<br>{<br>&nbsp;&nbsp;&nbsp;for (int aValue: a)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean found = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int bValue: b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bValue == aValue)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!found)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;return true;<br>}<br></code><br>Which best describes what method <code>findSomething</code> does? Method <code>findSomething</code> returns <code>true</code> only if<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;Arrays a and b contain identical elements in the same order.";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;Arrays a and b contain identical elements in reverse order.";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;Arrays a and b are permutations of each other.";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;Array a contains at least one element that is also in b.";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;Every element of array a is also in b, and every element of array b is also in a.";

questions[qIndex].correctAnswers=E;

    
    
  //Q37 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="A word creation game uses a set of small letter tiles, all of which are initially in a tile bag. A partial implementation of a TileBag class is shown below.<br><br><code>public class TileBag<br>{<br>&nbsp;&nbsp;&nbsp;//tiles contains all the tiles in the bag<br>&nbsp;&nbsp;&nbsp;private List<Tile> tiles;<br>&nbsp;&nbsp;&nbsp;//size is the number of not-yet-used tiles<br>&nbsp;&nbsp;&nbsp;private int size;<br><br>&nbsp;&nbsp;&nbsp;//Constructors and other methods are not shown. <br>}</code><br><br>Consider the following method in the TileBag class that allows a player to get a new tile from the TileBag.<br><br><code>public Tile getNewTile()<br>{<br>&nbsp;&nbsp;&nbsp;if (size == 0)&nbsp;&nbsp;&nbsp;//no tiles left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;int index = (int) (Math.random() * size);<br>&nbsp;&nbsp;&nbsp;size--;<br>&nbsp;&nbsp;&nbsp;Tile temp = tiles.get(index);<br><br>&nbsp;&nbsp;&nbsp;/* code to swap tile at position size with tile at position index */<br><br>&nbsp;&nbsp;&nbsp; return temp;<br>}</code><br><br>Which <code>/* code to swap tile at position size with tile at position index */</code> performs the swap correctly?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;<code>tiles.set(size, temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tiles.set(index, tiles.get(size));</code>";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;<code>tiles.set(index,tiles.get(size));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tiles.set(size, temp);</code>";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;<code>tiles.swap(index, size);</code>";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;<code>tiles.get(size, temp);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tiles.get(index, tiles.set(size));</code>";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;<code>tiles.get(index, tiles.set(size));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tiles.get(size, temp);</code>";
questions[qIndex].correctAnswers=B;
   
    
    
  //Q38 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="A word creation game uses a set of small letter tiles, all of which are initially in a tile bag. A partial implementation of a TileBag class is shown below.<br><br><code>public class TileBag<br>{<br>&nbsp;&nbsp;&nbsp;//tiles contains all the tiles in the bag<br>&nbsp;&nbsp;&nbsp;private List<Tile> tiles;<br>&nbsp;&nbsp;&nbsp;//size is the number of not-yet-used tiles<br>&nbsp;&nbsp;&nbsp;private int size;<br><br>&nbsp;&nbsp;&nbsp;//Constructors and other methods are not shown. <br>}</code><br><br>Consider the following method in the TileBag class that allows a player to get a new tile from the TileBag.<br><br><code>public Tile getNewTile()<br>{<br>&nbsp;&nbsp;&nbsp;if (size == 0)&nbsp;&nbsp;&nbsp;//no tiles left<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;int index = (int) (Math.random() * size);<br>&nbsp;&nbsp;&nbsp;size--;<br>&nbsp;&nbsp;&nbsp;Tile temp = tiles.get(index);<br><br>&nbsp;&nbsp;&nbsp;/* code to swap tile at position size with tile at position index */<br><br>&nbsp;&nbsp;&nbsp; return temp;<br>}</code><br><br>Which is true about the <code>getNewTile</code> algorithm?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;The algorithm allows the program to keep track of both used and unused tiles.";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;The tiles list becomes one element shorter when <code>getNewTile</code> is executed.";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;The algorithm selects a random Tile from all tiles in the list.";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;The tiles list has used tiles in the beginning and unused tiles at the end.";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;The tiles list contains only tiles that have not been used.";
questions[qIndex].correctAnswers=A;    
    
    
     
  //Q40 from Diagnostic Test
qIndex=qIndex+1;
questions[qIndex] = new Question();
questions[qIndex].number=qIndex+1;
questions[qIndex].type="SING_ANS";
questions[qIndex].question="Consider a method <code>partialProd</code> that returns an integer array <code>prod</code> such that, for all k, prod[k] is equal to arr[0] * arr[1] * ···arr[k]. For example, if arr contains the values {2,5,3,4,10}, the array prod will contain the values {2,10,30,120,1200}.<br><br><code>public static int[] partialProd(int[] arr)<br>{<br>&nbsp;&nbsp;&nbsp;int[] prod = new int[arr.length];<br>&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; arr.length; j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod[j] = 1;<br>&nbsp;&nbsp;&nbsp; /* missing code */<br>&nbsp;&nbsp;&nbsp;return prod;<br>}</code><br><br>Consider the following two implementations of /* missing code */.<br><u>Implementation 1</u><br><br><code>for (int j = 1; j &lt; arr.length; j++)<br> {<br>&nbsp;&nbsp;&nbsp;prod[j] = prod[j - 1] * arr[j];<br>}</code><br><br><u>Implementation 2</u><br><br><code>for (int j = 0; j &lt; arr.length; j++)<br>&nbsp;&nbsp;&nbsp; for (int k = 0; k &lt;= j; k++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prod[j] = prod[j] * arr[k];<br>&nbsp;&nbsp;&nbsp;}<br>}</code><br><br>Which of the following statements is true?<br>";

questions[qIndex].choices[0]="&nbsp;&nbsp;&nbsp;Both implementations work as intended but Implementation 1 is faster than Implementation 2";
questions[qIndex].choices[1]="&nbsp;&nbsp;&nbsp;Both implementations work as intended but Implementation 2 is faster than Implementation 1";
questions[qIndex].choices[2]="&nbsp;&nbsp;&nbsp;Both implementations work as intended and are equally fast.";
questions[qIndex].choices[3]="&nbsp;&nbsp;&nbsp;Implementation 1 doesn’t work as intended because the elements of <code>prod</code> are incorrectly assigned.";
questions[qIndex].choices[4]="&nbsp;&nbsp;&nbsp;Implementation 2 doesn’t work as intended because the elements of <code>prod</code> are incorrectly assigned.";
questions[qIndex].correctAnswers=D;    
    
    
	totalQuestions = qIndex+1;
	currentQuestion = questions[0];
	displayQuestion();
}

function displayQuestion(){
	qDiv.innerHTML = "Question " + currentQuestion.number + ":<br><br>";
	qDiv.innerHTML += currentQuestion.question + "<br>";
	if(currentQuestion.type == "MULT_ANS"){
		qDiv.innerHTML += "<br>	(choose all that apply)<br>";

		for(var i = 0; i < currentQuestion.choices.length; i++){
            qDiv.innerHTML += "&nbsp;" + numToChar(i) + ":&nbsp;&nbsp;";
			if(currentQuestion.userAnswers.includes(i)){
				qDiv.innerHTML += "<input type='checkbox' checked></input>";
			}else{
				qDiv.innerHTML += "<input type='checkbox'></input>";
			}


			qDiv.innerHTML += currentQuestion.choices[i] + "<br>";

		}

		if(quizComplete){
			qDiv.innerHTML += "<b>Correct Answer:</b><br>";
			for(var j = 0; j < currentQuestion.correctAnswers.length; j++){
				qDiv.innerHTML += currentQuestion.choices[currentQuestion.correctAnswers[j]] + "<br><br>";
			}
			qDiv.innerHTML += "<b>Your Answer:</b><br>";
			for(var j = 0; j < currentQuestion.userAnswers.length; j++){
				qDiv.innerHTML += currentQuestion.choices[currentQuestion.userAnswers[j]] + "<br><br>";
			}
		}

	}else if(currentQuestion.type == "SING_ANS"){

		for(var i = 0; i < currentQuestion.choices.length; i++){
			qDiv.innerHTML += numToChar(i) + ":&nbsp;&nbsp;";

			if(currentQuestion.userAnswers == i){
				qDiv.innerHTML += "<input type='radio' name='q"+currentQuestion.number+"' checked></input>";
			}else{
				qDiv.innerHTML += "<input type='radio' name='q"+currentQuestion.number+"'></input>";
			}
			qDiv.innerHTML += currentQuestion.choices[i] + "<br>";

		}

		if(quizComplete){
			qDiv.innerHTML += "<b>Correct Answer:</b><br>";
			qDiv.innerHTML += currentQuestion.choices[currentQuestion.correctAnswers] + "<br><br>";

			qDiv.innerHTML += "<b>Your Answer:</b><br>";
			qDiv.innerHTML += currentQuestion.choices[currentQuestion.userAnswers] + "<br><br>";
		}
	}else if(currentQuestion.type == "FILL_IN"){
		qDiv.innerHTML += "<textarea rows='7' cols='60'>"+currentQuestion.userAnswers+"</textarea>";
		if(quizComplete){
			qDiv.innerHTML += "<br><b>Correct Answer:</b><br>";
			qDiv.innerHTML += currentQuestion.correctAnswers + "<br><br>";

			qDiv.innerHTML += "<b>Your Answer:</b><br>";
			qDiv.innerHTML += currentQuestion.userAnswers + "<br><br>";
		}
	}
	qDiv.innerHTML += "<br>";

	if(currentQuestion.number != 1){
		qDiv.innerHTML += "<button onclick='previousQuestion()'>Previous Question</button>";
	}
    if (currentQuestion.number >1 && currentQuestion.number < questions.length) {
        qDiv.innerHTML += "&nbsp;&nbsp;&nbsp;&nbsp;"
    }
    if(currentQuestion.number != questions.length){
		qDiv.innerHTML += "<button onclick='nextQuestion()'>Next Question</button>";
	}

	qDiv.innerHTML += "<hr size='3'>";
}

function submitQuiz(){
	if(quizComplete) return;
	if(!confirm("Are you sure you want to submit your quiz for grading?")) return;
	quizComplete = true;
	saveQuestionState();

	scoreQuiz();
	highlightButtons();

	currentQuestion = questions[0];
	displayQuestion();
}

function specialParseStr(str){
	var nstr = "";
	for(var i = 0; i < str.length; i++){
		var c = str.charAt(i);
		if(c == '\"'){
			nstr += "\\\"";
		}else if(c == '<'){
			nstr += "&lt";
		}else if(c == '\n' || c == ' '){

		}else{
			nstr += c;
		}
	}
	return nstr.trim();
}

function scoreQuiz(){
	for(var i = 0; i < questions.length; i++){
		if(questions[i].type == "MULT_ANS"){
			var ca = compareArray(questions[i].correctAnswers, questions[i].userAnswers);
			questions[i].isCorrect = ca;
			if(ca) score++;
		}else if(questions[i].type == "SING_ANS"){
			if(questions[i].correctAnswers == questions[i].userAnswers){
				questions[i].isCorrect = true;
				score++;
			}
		}else if(questions[i].type == "FILL_IN"){
			if(specialParseStr(questions[i].correctAnswers) == specialParseStr(questions[i].userAnswers)){
				questions[i].isCorrect = true;
				score++;
			}
		}
	}

	score /= totalQuestions;
	score *= 100;

	var hdr = document.getElementById("header");
	hdr.innerHTML += "<center><h1><b>Score: "+score.toFixed(2)+"%</b></h1></center>";
}

function nextQuestion(){
	saveQuestionState();
	currentQuestion = questions[currentQuestion.number];
	displayQuestion();
}

function previousQuestion(){
	saveQuestionState();
	currentQuestion = questions[currentQuestion.number - 2];
	displayQuestion();
}

function navigateTo(i){
	saveQuestionState();
	currentQuestion = questions[i];
	displayQuestion();
}

function highlightButtons(){
	var btns = navDiv.getElementsByTagName("button");
	for(var i = 0; i < questions.length; i++){
		if(questions[i].isCorrect){
			btns[i].style="background-color:green";
		}else{
			btns[i].style="background-color:red";
		}
	}
}

function saveQuestionState(){
	if(currentQuestion.type == "MULT_ANS"){
		currentQuestion.userAnswers = [];
		var cbx = qDiv.getElementsByTagName("input");
		for(var i = 0; i < cbx.length; i++){
			if(cbx[i].checked){
				currentQuestion.userAnswers.push(i);
			}
		}
	}else if(currentQuestion.type == "SING_ANS"){
		currentQuestion.userAnswers = [];
		var cbx = qDiv.getElementsByTagName("input");
		for(var i = 0; i < cbx.length; i++){
			if(cbx[i].checked){
				currentQuestion.userAnswers = i;
			}
		}
	}else if(currentQuestion.type == "FILL_IN"){
		var tbx = qDiv.getElementsByTagName("textarea");
		currentQuestion.userAnswers = tbx[0].value;
	}
}

function numToChar(num){
	return String.fromCharCode("A".charCodeAt(0) + num);
}

function compareArray(arr1, arr2){
	if(arr1.length != arr2.length){
		return false;
	}

	for(var i = 0; i < arr1.length; i++){
		if(arr1[i] != arr2[i]){
			return false;
		}
	}

	return true;
}

</script>

</html>
